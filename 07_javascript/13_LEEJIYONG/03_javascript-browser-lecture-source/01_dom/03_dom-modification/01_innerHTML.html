<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <!-- <div id="area">노드 정보 취득</div> -->

    <script>
      // console.log(document.nodeType);
      // console.log(document.nodeName);
      // const $area = document.getElementById("area");
      // console.log($area.nodeType);
      // console.log($area.nodeName);
      // const $textNode = $area.firstChild;
      // console.log($textNode.nodeType);
      // console.log($textNode.nodeName);
    </script>

    <div id="area">nodeValue</div>

    <script>
      console.log(document.nodeValue);
      const $area = document.getElementById("area");
      console.log($area.nodeValue);
      const $textNode = $area.firstChild;
      console.log($textNode.nodeValue);
      $textNode.nodeValue = "텍스트 값 변경 완료!";
    </script>

    <div id="area2">textContent<span>내부 span</span></div>
    <script>
      const $area2 = document.getElementById("area2");
      // HTML의 마크업이 무시 된 div 내부의 컨텐츠를 텍스트로 취득
      console.log($area2.textContent);
      // nodeValue는 텍스트 노드의 값만 반환하므로 textContent보다 코드가 복잡해진다
      console.log($area2.nodeValue); // null
      console.log($area2.firstChild.nodeValue); // textContent
      console.log($area2.lastChild.firstChild.nodeValue); // 내부 span
      // area2의 모든 자식 노드가 제거 되고 할당한 문자열이 텍스트로 추가 된다.
      // HTML 마크업이 파싱되지 않는다.
      $area2.textContent = "텍스트 값 변경 완료!<span>내부 span</span>";
    </script>

    <pre>
      textContent 프로퍼티는 HTML 마크업을 무시하고 텍스트만 반환하지만 innerHTML 프로퍼티는
      HTML 마크업이 포함 된 문자열을 그대로 반환한다.
    </pre>

    <div id="area4">
      태그 엘리먼트의 값을 읽거나, 변경할떄 <span>innerHTML</span>
      속성을 사용하면 된다.
    </div>
    <script>
      const $area4 = document.getElementById("area4");
      console.log($area4.innerHTML);

      // 노드 추가
      $area4.innerHTML += "값 추가";
      // 노드 교체
      $area4.innerHTML = "<h1>innerHTML</h1>속성으로 값 변경";
      // 노드 삭제
      $area4.innerHTML = "";

      // $area4.innerHTML = `<img src='x' onerror='alert("메롱메롱~")'>`;
    </script>

    <ul id="list">
      <li class="coffee">커피</li>
    </ul>

    <script>
      const $list = document.getElementById("list");
      // 노드 추가
      $list.innerHTML += "<li class='coke'>콜라</li>";
      // 위 코드는 아래 코드의 축약 표현으로 유지 되어도 되는 기존의 자식 노드까지 모두 제거하고 새롭게 자식 노드를 생성하여 DOM에 반영하는 비효율적인 동작을 한다.
      $list.innerHTML = $list.innerHTML + "<li class='coke'>콜라</li>";
      // 커피와 콜라 사이에 새로운 요소를 삽입하고 싶을 경우 innerHTML을 통해서는 삽입 위치를 지정할 수 없다.
      // 기존 요소를 제거하지 않으면서 위치를 지정해 새로운 요소를 삽입해야 할 때는 insertAdjacentHTML 메서드를 사용하는
      // 것이 더 효율적이다.
    </script>

    <div id="area5">insertAdjacentHTML 메소드 사용 테스트</div>

    <script>
      const $area5 = document.getElementById("area5");
      $area5.insertAdjacentHTML("beforebegin", "<h1>beforebegin 테스트</h1>");
      $area5.insertAdjacentHTML("afterbegin", "<h1>afterbegin 테스트</h1>");
      $area5.insertAdjacentHTML("beforeend", "<h1>beforeend 테스트</h1>");
      $area5.insertAdjacentHTML("afterend", "<h1>afterend 테스트</h1>");
    </script>
  </body>
</html>
